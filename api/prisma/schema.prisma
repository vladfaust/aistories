// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider   = "prisma-client-js"
  engineType = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Settings {
  key         String   @id
  value       String
  description String
  updatedAt   DateTime @updatedAt
}

model User {
  id String @id // Nanoid

  openAiApiKey String?

  createdAt DateTime @default(now())

  Stories Story[] // Stories the user owns
  Content StoryContent[] // User-generated content

  OAuth2Identities OAuth2Identity[]
}

model OAuth2Provider {
  id String @id

  clientId    String
  redirectUri String

  OAuth2Identities OAuth2Identity[]
}

model OAuth2Identity {
  providerId String
  userId     String

  externalId String

  accessToken String
  tokenType   String
  scope       String?

  expiresAt    DateTime
  refreshToken String?

  User     User           @relation(fields: [userId], references: [id])
  Provider OAuth2Provider @relation(fields: [providerId], references: [id])

  @@id([providerId, userId])
}

model CharacterCollection {
  id Int @id @default(autoincrement())

  imageUrl String
  name     String
  about    String

  setup String // The initial setup of the story, present in all prompts

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Characters Character[]
  Stories    Story[]
}

model Character {
  id Int @id @default(autoincrement())

  collectionId Int

  // TODO: Rename to avatarUrl
  imagePreviewUrl String

  name  String // E.g. "Spot"
  // TODO: Remove title
  title String // E.g. "The all-seeing dog"
  about String // Short description

  personality String // Used in a prompt, should be hidden from the user

  Collection CharacterCollection @relation(fields: [collectionId], references: [id])
  Stories    Story[] // Stories the character is participating in
  Memories   StoryMemory[] // Memories of the character
  Content    StoryContent[] // Content created by the character (user-controlled or not)
}

model Story {
  id String @id // Nanoid

  userId       String // Id of the user who owns the story
  collectionId Int // Id of the character collection used in the story
  charIds      Int[] // All characters in the story (including user-controlled ones)
  userCharId   Int // The character controlled by the user

  name   String? // Display name of the story
  fabula String? // The initial context of the story, further augmented by memories

  summary    String? // The summary of the story until the latest checkpoint
  checkpoint Int? // The id until which the content is summarized into memories
  reason     String? // Reason for failure, if any

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Owner      User                @relation(fields: [userId], references: [id])
  Collection CharacterCollection @relation(fields: [collectionId], references: [id])
  Characters Character[]
  Content    StoryContent[]
  Memories   StoryMemory[]
}

model StoryContent {
  id Int @id @default(autoincrement())

  storyId String
  charId  Int
  userId  String? // If null, the content is generated by the system

  content     String
  tokenLength Int // Total number of tokens in the content
  tokenUsage  Int // Total number of tokens used to generate the content

  createdAt DateTime @default(now())

  Story     Story     @relation(fields: [storyId], references: [id])
  Character Character @relation(fields: [charId], references: [id])
  User      User?     @relation(fields: [userId], references: [id])
}

// A story memory per (character) actor.
// Not saved for a user-controlled character.
model StoryMemory {
  storyId String
  charId  Int

  memory     String
  tokenUsage Int // Total number of tokens used to generate the memory

  Story     Story     @relation(fields: [storyId], references: [id])
  Character Character @relation(fields: [charId], references: [id])

  @@id([storyId, charId])
}
