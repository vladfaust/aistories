// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Settings {
  key         String   @id
  value       String
  description String
  updatedAt   DateTime @updatedAt
}

model User {
  id Int @id @default(autoincrement()) // TODO: Nanoid

  openAiApiKey String?

  createdAt DateTime @default(now())

  Stories Story[] // Stories the user owns
  Content StoryContent[] // User-generated content

  // NOTE: For now, only a single web3 identity per user is supported.
  Web3Identities   Web3Identity[]
  OAuth2Identities OAuth2Identity[]
}

model Web3Identity {
  address Bytes @id
  userId  Int

  User User @relation(fields: [userId], references: [id])

  @@unique([address, userId])
}

model OAuth2Provider {
  id String @id

  clientId    String
  redirectUri String

  OAuth2Identities OAuth2Identity[]
}

model OAuth2Identity {
  providerId String
  userId     Int

  externalId String

  accessToken String
  tokenType   String
  scope       String?

  expiresAt    DateTime
  refreshToken String?

  User     User           @relation(fields: [userId], references: [id])
  Provider OAuth2Provider @relation(fields: [providerId], references: [id])

  @@id([providerId, userId])
}

model Character {
  id Int @id @default(autoincrement())

  // TODO: Rename to avatarUrl
  imagePreviewUrl String

  name  String // E.g. "Spot"
  // TODO: Remove title
  title String // E.g. "The all-seeing dog"
  about String // Short description

  personality String // Used in a prompt, should be hidden from the user

  erc1155Address Bytes?
  erc1155Id      Bytes?
  erc1155NftUri  String?

  Stories  Story[] // Stories the character is participating in
  Memories StoryMemory[] // Memories of the character
  Content  StoryContent[] // Content created by the character (user-controlled or not)
}

model Story {
  id Int @id @default(autoincrement())

  userId     Int // Id of the user who owns the story
  charIds    Int[] // All characters in the story (including user-controlled ones)
  userCharId Int // Mapping from a user ID to their character ID
  nextCharId Int // Id of the next character to act

  name   String? // Display name of the story
  setup  String? // The initial setup of the story, present in all prompts
  fabula String? // The initial context of the story, augmented by memories
  buffer Int[]   @default([]) // Recent content buffer

  busy   Boolean // Is the story generation in progress?
  pid    Bytes?  @unique // Process responsible for the generation
  reason String? // Reason for the generation stoppage

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Owner      User           @relation(fields: [userId], references: [id])
  Characters Character[]
  Content    StoryContent[]
  Memories   StoryMemory[]
}

model StoryContent {
  id Int @id @default(autoincrement())

  storyId Int
  charId  Int
  userId  Int? // If null, the content is generated by the system

  tokenLength Int // Number of tokens in the content
  content     String? // Content generation may be in progress
  createdAt   DateTime @default(now())

  Story       Story         @relation(fields: [storyId], references: [id])
  Character   Character     @relation(fields: [charId], references: [id])
  User        User?         @relation(fields: [userId], references: [id])
  Checkpoints StoryMemory[]
}

// A story memory per (character) actor.
// Not saved for a user-controlled character.
model StoryMemory {
  storyId Int
  charId  Int

  checkpoint Int
  memory     String

  Story      Story        @relation(fields: [storyId], references: [id])
  Character  Character    @relation(fields: [charId], references: [id])
  Checkpoint StoryContent @relation(fields: [checkpoint], references: [id])

  @@id([storyId, charId])
}
